{
  "hash": "e9f4ee8ff3ceb931d1d06300870cdf4f",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Dynamic Documentaion with Quarto\"\nsubtitle: \"A common pattern to create dynamic documation\"\nauthor: \"Matthew Scott\"\ndate: \"2025-07-29\"\ndescription: \"Make use of quarto's integration with mermaid diagrams and create dynamic and asthetic documentation\"\ncategories: [blog, r, quarto, mermaid]\nimage: \"spiral.png\"\nimage-alt: \"An abtract wagon's wheel\"\ncode-annotations: hover\ndraft: false\ntoc: true\n---\n\n# Introduction\n\nVisual documentation is great for grabbing your readers attention but keeping it up to date can be a pain. Often due to the overhead of this task your documentation can drift from the reality of a project and over time go out of fashion. Now no one is using the documentation you spent so long creating because it does not reflect the current state of the code - inaccuracies or incompleteness means other developers (and yourself) have left it behind. You now rely on *tacit* knowledge^[knowledge kept inside someones head] to keep your project alive. If you want to continue to receive vindication for all the hard hours that have been spent creating this software, that person better not leave the organisation.\n\nBut there is light at the end of the tunnel - in recent years there has been a real push to create *dynamic* documentation - as your code evolves, so does the documentation; automatically. Packages like [Sphinx](https://www.sphinx-doc.org/en/master/) in the *pythonic* world are used often (see the [Numpy](https://numpy.org/doc/stable/) documentation), and Quarto is already used by libraries to create thorough and visually intuitive documentation - see [Ibis](https://ibis-project.org/) or [FastHTML](https://fastht.ml/docs/). I will show you a pattern to create dynamic documentation that takes advantage of Quarto's integration with Mermaid diagrams and can be used to render HTML documentation that, when refreshed, will update to reflect the current state of a project.\n\n# The process\n\nFor this example we will create a couple of toy tables to demonstrate how an entity relationship diagram can be displayed in your quarto-rendered documentation. You would want to replace this step with a dynamic call to return a dataframe from your underlying database schema. For example, using a DBI connection to a SQL database, you could run \n\n```{{sql}}\nSELECT \n    table_name,\n    column_name,\n    data_type,\n\nFROM  INFORMATION_SCHEMA.COLUMNS\n```\n\nThis is what the process looks like from a high level:\n\n```{mermaid}\n%%| eval: true\nflowchart TD\n    A(Return schema)\n    B(Use string methods to create a <br> marmaid-compliant string <br> from your dataframe)\n    C(Save string to .mmd file)\n    D(Call file in mermaid cell block of quarto document)\n    A --> B --> C --> D \n```\n\nLet's focus in on a specific example to give some clarity\n\nOk, say you want to use mermaid to map an ERD of a database schema you have created as part of a project. You can use `dbplyr` to query the information schema of this database. Use `glue` and `dplyr` to iterate through the resulting dataframe to create a mermaid-compliant string. This can then be written to a `.mmd` file and referenced in your Quarto-rendered HTML file.\n\n:::{.callout-note icon=\"true\" collapse=\"true\"}\n## Sample data\n\nI will use a toy dataset similar to what you could return with the above SQL call:\n\n::: {.cell}\n\n```{.r .cell-code}\n# use data that ships with dplyr\nlibrary(dplyr)\n\n# create a tibble of table metadata for band_members\n# & band_instruments tables similar to what you'd get\n# querying a database tables information schema\ntables <- c(\"band_members\", \"band_instruments\") |>\n    purrr::map_df(\n        ~ tibble(\n            table_name = .,\n            column_name = names(get(.)),\n            data_type = purrr::map_chr(get(.), class)\n        )\n    )\n\ntables\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 4 Ã— 3\n  table_name       column_name data_type\n  <chr>            <chr>       <chr>    \n1 band_members     name        character\n2 band_members     band        character\n3 band_instruments name        character\n4 band_instruments plays       character\n```\n\n\n:::\n:::\n\n\n:::\n\n## Reshape data & save `.mmd` file\nBelow we are reshaping our dataframe into a mermaid-compliant string and saving a `.mmd` file out to our working directory\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(glue)\n\n# Build Mermaid blocks for each table\ner_blocks <- tables |>\n    group_by(table_name) |>\n    reframe(\n        block = glue(\" {data_type} {column_name}\")\n    ) |>\n    group_by(table_name) |>\n    summarise(\n        table_block = glue(\"{first(table_name)} {{{paste(block, collapse = ' ')}}}\"),\n        .groups = \"drop\"\n    ) |>\n    pull(table_block)\n\n# Combine all table blocks into one Mermaid diagram\ner_diagram <- glue(\"erDiagram {paste(er_blocks, collapse = ' ')}\")\n\n# write string to a mermaid file using .mmd suffix\nwrite(er_diagram, \"erd.mmd\")\n```\n:::\n\n\n## Create mermaid ERD\nCall the file by including in a mermaid code block using the `file` argument:\n\n```{{mermaid}}\n%%| eval: true\n%%| file: \"erd.mmd\"\n```\nWhich renders an ERD in your quarto output:\n\n```{mermaid}\n%%| eval: true\n%%| file: \"erd.mmd\"\nerDiagram band_instruments { character name  character plays} band_members { character name  character band}\n```\n\n# Improvements to this workflow\n\n- Expand on the EDR by adding [relationships](https://mermaid.js.org/syntax/entityRelationshipDiagram.html) between tables\n- Create other types of mermaid diagram\n    - A [Gantt chart](https://mermaid.js.org/syntax/gantt.html) that dynamically updates with task timelines\n    - [Flowcharts](https://mermaid.js.org/syntax/flowchart.html) are also cool for conveying high level information (and used in this article)\n- There could be scope for a package that transforms dataframes into mermaid-compliant strings. I'm not sure if one already exists.",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}