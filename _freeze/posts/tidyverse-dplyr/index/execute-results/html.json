{
  "hash": "d53c8a4e4587c5a9450008e85a8ff828",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Tidyverse Essentials - `dplyr`\"\nsubtitle: \"The grammar of data wrangling\"\nauthor: \"Matthew Scott\"\ndate: \"2024-07-24\"\ndescription: \"Data wrangling: solve the most common data manipulation challenges\"\ncategories: [tutorial, r, tidyverse, dplyr, intro]\nimage: \"abstract-art.png\"\nimage-alt: \"An abstract sketch whos colours bleed into the canvas\"\ncode-annotations: hover\ndraft: false\ntoc: true\n---\n\n\n![Abstract Canvas](abstract-art-wide.png){fig-alt=\"A cropped version of the main image\"}\n\n::: {.cell}\n\n:::\n\n\n## Introduction\n\ndplyr helps manipulate datasets. That is, it can be used to change their shape - the number of rows, columns, as well as verbs to create new columns.\n\n### Dataset used in this tutorial\n\nWe will use the `mpg` dataset from [**ggplot2**]{.text-warning} in this tutorial and run through a lot of the common syntax used to manipulate a table.\n\n:::{.callout-note icon=\"true\" collapse=\"true\"}\n## mpg\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(ggplot2)\nglimpse(mpg) # <1>\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nRows: 234\nColumns: 11\n$ manufacturer <chr> \"audi\", \"audi\", \"audi\", \"audi\", \"audi\", \"audi\", \"audi\", \"…\n$ model        <chr> \"a4\", \"a4\", \"a4\", \"a4\", \"a4\", \"a4\", \"a4\", \"a4 quattro\", \"…\n$ displ        <dbl> 1.8, 1.8, 2.0, 2.0, 2.8, 2.8, 3.1, 1.8, 1.8, 2.0, 2.0, 2.…\n$ year         <int> 1999, 1999, 2008, 2008, 1999, 1999, 2008, 1999, 1999, 200…\n$ cyl          <int> 4, 4, 4, 4, 6, 6, 6, 4, 4, 4, 4, 6, 6, 6, 6, 6, 6, 8, 8, …\n$ trans        <chr> \"auto(l5)\", \"manual(m5)\", \"manual(m6)\", \"auto(av)\", \"auto…\n$ drv          <chr> \"f\", \"f\", \"f\", \"f\", \"f\", \"f\", \"f\", \"4\", \"4\", \"4\", \"4\", \"4…\n$ cty          <int> 18, 21, 20, 21, 16, 18, 18, 18, 16, 20, 19, 15, 17, 17, 1…\n$ hwy          <int> 29, 29, 31, 30, 26, 26, 27, 26, 25, 28, 27, 25, 25, 25, 2…\n$ fl           <chr> \"p\", \"p\", \"p\", \"p\", \"p\", \"p\", \"p\", \"p\", \"p\", \"p\", \"p\", \"p…\n$ class        <chr> \"compact\", \"compact\", \"compact\", \"compact\", \"compact\", \"c…\n```\n\n\n:::\n:::\n\n1. We can see the column names, their datatype (inside `< >`) and example data in a list-like format. We also get information on the number of rows and columns, the 'shape'\n:::\n\n## `select()` & `rename()`\n\nChoose which columns to include or exclude.\n\n`select([df], helper_function([col_1], [col_2]))`\n\nYou can wrap the columns in helper functions:\n\n* `contains(match, ignore.case = T)` - column name contains a certain string\n* `starts_with(match, ignore.case = T)` - column names start with\n* `ends_with(match, ignore.case = T)` - column names end with\n* `matches(match, ignore.case = T)` - matches a regular expression\n* `num_range(prefix, range, ...)` - names following the pattern e.g. `num_range(\"Wk\", 1:3)`: \"Wk1\", \"Wk2\", \"Wk3\"\n* `any_of()` - will select all columns available from a list\n* `all_of()` - used for strict selection. Throws an error if one of the columns named in the list aren't present in the dataframe\n* `matches()` - exactly matches a certain string\n* `everything()` - every other column not specified already\n* `where(is.numeric())` - will select all numeric columns (int or dbl). Also `is.character`, `is.factor`, `is.integer`, `is.double`\n\n`rename([new_name] = [old_name])`\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# selecting column by index (position)\n\n# select columns in position 1-3\nselect(df, 1:3)\n# select columns in position 1-3\nselect(df, c(2, 5, 7))\n# select from the second to last column to the last column\nselect(df, (ncol(df) -2) : ncol(df))\n\n# selecting columns that contain 'l' (upper or lower case) \n# and renaming 'model' to 'type' etc.\ndf %>%  \n  select(contains('l', ignore.case = T)) %>% \n  rename(type = model, cylinder = cyl)\n\n# select and rename in one call\nselect(df, \n       mnfc = manufacturer, # <1>\n       mod = model, # <1>\n       everything()) # <2>\n\n# select all numeric columns plus some extras\nmpg %>%\n  select(where(is.numeric), # <3>\n         mnfc = manufacturer, # <4>\n         mod = model) # <4>\n\n# another approach: create a vector and use this with any_of()\nnumerical_cols <- c('displ', 'year', 'cyl', 'cty', 'hwy')\nnumerical_df <- df %>% \n  select(any_of(numerical_cols))\n\n# negative selections\ndf %>% \n  select(-any_of(c(model, displ, cyl))) # <5>\n```\n:::\n\n\n1. select and rename in one call\n2. select all remaining columns that haven't already been specified\n3. this will select all column of data type int or dbl\n4. add two additional non-numeric cols to your selection\n5. remove any of these columns that appear in the data frame\n\n## `mutate()` & `transmute()`\n\nCreate new columns from existing ones.\n\n`mutate([new_col] = [old_col(s) + logic])`\n\n* creates a new column based on the logic provided\n* you can create multiple columns at one time\n* adds the new col to the df\n\n`transmute([new_col] = [old_col(s) + logic])`\n\n* creates a new column and drops other columns (this can be useful when do machine learning and you don't want the new columns interfering with the model)\n\nHelpful functions for dealing with strings:\n\n| Functions | \n|:------:|\n| `as.character()` | \n| `as.date()` | \n| `as.integer()` | \n\n: {.striped .hover}\n\n**Note** There is also `lubridate` and `hms` packages for working with dates and times that give a lot more flexibility. `stringr` is another useful package commonly used with mutate to extract parts of string columns.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# create 'avg mpg' column and paste together two cols into 'car'\n# this will return the full df plus these two new cols\nmpg %>% \n    mutate(\n         car = paste(manufacturer, model, sep = ' '),\n        `avg mpg` = (( cty + hwy ) / 2 ),\n         cty, # <1>\n        .keep = \"none\") %>%  # <2>\n    head(5)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 5 × 3\n    cty car     `avg mpg`\n  <int> <chr>       <dbl>\n1    18 audi a4      23.5\n2    21 audi a4      25  \n3    20 audi a4      25.5\n4    21 audi a4      25.5\n5    16 audi a4      21  \n```\n\n\n:::\n:::\n\n1. We can specify the col name with no calc and it will get included\n2. Acts like `transmute` to keep only created columns\n\nUse `.by` to group our selection in a single expression. We return the max avg mpg for each model type:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmpg %>% \n    mutate(`avg mpg` = ((cty+hwy)/2),\n           `max avg mpg` = max(`avg mpg`),\n           .by = model,\n           .keep = \"used\") # <1>\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 234 × 5\n   model        cty   hwy `avg mpg` `max avg mpg`\n   <chr>      <int> <int>     <dbl>         <dbl>\n 1 a4            18    29      23.5          25.5\n 2 a4            21    29      25            25.5\n 3 a4            20    31      25.5          25.5\n 4 a4            21    30      25.5          25.5\n 5 a4            16    26      21            25.5\n 6 a4            18    26      22            25.5\n 7 a4            18    27      22.5          25.5\n 8 a4 quattro    18    26      22            24  \n 9 a4 quattro    16    25      20.5          24  \n10 a4 quattro    20    28      24            24  \n# ℹ 224 more rows\n```\n\n\n:::\n:::\n\n1. Now we keep only columns used in our mutate verb, including those used in the calculations.\n\n### Common usage\n\nReplace existing columns with mutated version of themselves, either by converting the data type or cleaning the column of NAs. Create new columns with mutate.\n\n- `case_when()`\n- `case_match()`\n- `if_else()`\n- `na_if()`\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# mutate with case_when\nmpg %>% \n    mutate(\n        \"hwy_bins\" = case_when(\n            hwy < 20 ~ \"low\",\n            between(hwy, 20, 30) ~ \"medium\",\n            hwy > 30 ~ \"high\",\n            TRUE ~ NA_character_\n            ))\n\n# mutate with if_else\nmpg %>% \n    mutate(\n        \"is_offroad\" = if_else(\n            drv == \"4\", \"Y\", \"N\"\n        ))\n\n# mutate with na_if() to replace values with NA\nmpg %>% \n    mutate(year = na_if(year, NaN)) # <1>\n```\n:::\n\n1. if NaN present, replace it with NA to help clean the column\n\n\n### Other mutate verbs\n\n* `mutate_all()` - affects every variable\n* `mutate_if()` - affects variables selected with a predicate function\n* `mutate_at()` - affects variables selected with a character variable or vars()\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# This code:\ntable_sep <- table %>%\n  separate(col = date,\n           into = c(\"year\", \"month\", \"dayofmonth\"),\n           sep = \"-\") %>%\n  mutate(month = as.numeric(month), # <1>\n         dayofmonth = as.numeric(dayofmonth)) %>% # <1>\n  arrange(year, month, dayofmonth)\n\n# is the same as this:\ntable_sep <- table %>%\n  separate(col = date,\n           into = c(\"year\", \"month\", \"dayofmonth\"),\n           sep = \"-\") %>%\n  mutate_at(.vars = c(\"month\", \"dayofmonth\"), # <2>\n            .funs = as.numeric) # <2>\n  arrange(year, month, dayofmonth)\n```\n:::\n\n1. Where we have to specify every column to change data type here...\n2. ...we can supply the columns in a list and only have to specify the mutate function once\n\nYou can imagine if we had lots of columns to mutate, this would be much more succinct.\n\n:::{.callout-note appearance=\"simple\" icon=\"true\"}\n## Note \nIt is generally preferred to use `across()` instead of the above verbs. See [Column-wise operations](https://dplyr.tidyverse.org/articles/colwise.html) for a detailed explanation of this.\n:::\n\nYou can mutate any column that is.character/is.numeric...:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmpg %>% \n    mutate_if(is.character, stringr::str_to_title) %>% # <1>\n    select(is.character) %>% \n    head(4)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 4 × 6\n  manufacturer model trans      drv   fl    class  \n  <chr>        <chr> <chr>      <chr> <chr> <chr>  \n1 Audi         A4    Auto(L5)   F     P     Compact\n2 Audi         A4    Manual(M5) F     P     Compact\n3 Audi         A4    Manual(M6) F     P     Compact\n4 Audi         A4    Auto(Av)   F     P     Compact\n```\n\n\n:::\n:::\n\n1. convert all character columns to title case (upper case at start of each word)\n\n### `across()`\n\n`across` works very well with `summarise()` & `mutate()`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmpg %>% \n    summarise(across(where(is.character), n_distinct)) # <1>\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 × 6\n  manufacturer model trans   drv    fl class\n         <int> <int> <int> <int> <int> <int>\n1           15    38    10     3     5     7\n```\n\n\n:::\n:::\n\n1. `across()` is used to apply the summary, `n_distint()`, across the selected columns - in this case all character columns\n\n## `filter()` & `slice()`\n\n### `filter()` \nUsed to extract or create a subset of rows based on logical operators\n- it will produce a new table\n\nLogical operators to use with `filter()`:\n\n| Operator | Meaning\n|:----:| :----:\n| `==` | equal to\n| `!=` | not equal to\n| `<` | less than\n| `>` | greater than\n| `<=` | less than or equal to\n| `>=` | greater than or equal to\n| `between()` | between two values (inclusive)\n| `!` | not\n| `is.na()` | is NA\n| `!is.na()` | is not NA\n| `%in%` | is in (a vector)\n| `|` | or\n| `&` | and\n| `xor()` | exclusive or - 'one or the other but not both'\n\n: {.striped .hover}\n\nFiltering a table:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# this is the same as '&'\nmpg %>% \n    filter(manufacturer == \"audi\",\n           year == 1999) %>%\n    head()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 × 11\n  manufacturer model      displ  year   cyl trans  drv     cty   hwy fl    class\n  <chr>        <chr>      <dbl> <int> <int> <chr>  <chr> <int> <int> <chr> <chr>\n1 audi         a4           1.8  1999     4 auto(… f        18    29 p     comp…\n2 audi         a4           1.8  1999     4 manua… f        21    29 p     comp…\n3 audi         a4           2.8  1999     6 auto(… f        16    26 p     comp…\n4 audi         a4           2.8  1999     6 manua… f        18    26 p     comp…\n5 audi         a4 quattro   1.8  1999     4 manua… 4        18    26 p     comp…\n6 audi         a4 quattro   1.8  1999     4 auto(… 4        16    25 p     comp…\n```\n\n\n:::\n:::\n\n\n### `slice()` \nUsed to select certain rows of the table based on row position\n\nRelated slice functions:\n\n- `slice_head()`\n- `slice_tail()`\n- `slice_sample()`\n- `slice_max()`\n- `slice_min()`\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# select rows 10-20\nslice(df, 10:20)\n\n# slice top 10 rows\nslice_head(df, n = 10)\n\n# select bottom rows\nslice_tail(df, prop = .1) # <1>\n\n# select 10 rows at random from df\nslice_sample(df, 10)\n# select rows at random based on proportion of df\nslice_sample(df, prop = .1)\n\ndf %>% slice_max(hwy, n = 10) # <2>\ndf %>% slice_min(hwy, prop = .1) # <2>\n```\n:::\n\n1. select the bottom 10% of the df\n2. order by the selected column and select the top/bottom rows\n\n:::{.callout-note appearance=\"simple\" icon=\"true\"}\n## `slice_sample()` Note \nslice-sample can be done in two main ways, by taking the sampled rows 'out' of the data frame (so when subsequent sample slices are made, they cannot be chosen again), or by 'replacing' the sample (so in subsequent sample slices the same rows can be chosen again).\n\nThis is done using the `replace =` argument:\n\n- `df %>% slice_sample(prop = .1, replace = True)`\n- `df %>% slice_sample(prop = .1, replace = False)`\n\n`replace = False` is the default.\n:::\n\n- You can set a seed for reproducibility. Using the same seed will yield the same random selection each time, useful for code reviews where your results need to be reproduced.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# use base r for this\nset.seed(200)\n```\n:::\n\n\n## `arrange()`\n\n`arrange([data], desc([column_a], [column_b], ...))`\n\n- Sort rows by columns or values that you define\n- Analogous to ORDER BY in SQL syntax\n- Can wrap columns in `desc()` to arrange in descending order\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# arrange by year asc\narrange(df, year)\n#  arrange by year desc\narrange(df, desc(year))\n# arrange by multiple columns\narrange(df, desc(cyl), displ) \n\n# or using the pipe\ndf %>% arrange(desc(year))\n```\n:::\n\n\n## `distinct()`\n`distinct([df], [col_a], [col_b], ...)`\n\n- Removes rows with duplicate values\n- Specify columns in distinct to select only those column\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# will create a table where the combination \n# of manufacturer and model is distinct\nmpg %>% \n  select(manufacturer, model) %>% \n  distinct() # <1>\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 38 × 2\n   manufacturer model             \n   <chr>        <chr>             \n 1 audi         a4                \n 2 audi         a4 quattro        \n 3 audi         a6 quattro        \n 4 chevrolet    c1500 suburban 2wd\n 5 chevrolet    corvette          \n 6 chevrolet    k1500 tahoe 4wd   \n 7 chevrolet    malibu            \n 8 dodge        caravan 2wd       \n 9 dodge        dakota pickup 4wd \n10 dodge        durango 4wd       \n# ℹ 28 more rows\n```\n\n\n:::\n:::\n\n1. Because no columns are specified, `distinct` returns all columns\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmpg %>% \n    group_by(model) %>% # <1>\n    distinct(manufacturer, .keep_all = T) %>%  # <2>\n    head()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 × 11\n# Groups:   model [6]\n  manufacturer model       displ  year   cyl trans drv     cty   hwy fl    class\n  <chr>        <chr>       <dbl> <int> <int> <chr> <chr> <int> <int> <chr> <chr>\n1 audi         a4            1.8  1999     4 auto… f        18    29 p     comp…\n2 audi         a4 quattro    1.8  1999     4 manu… 4        18    26 p     comp…\n3 audi         a6 quattro    2.8  1999     6 auto… 4        15    24 p     mids…\n4 chevrolet    c1500 subu…   5.3  2008     8 auto… r        14    20 r     suv  \n5 chevrolet    corvette      5.7  1999     8 manu… r        16    26 p     2sea…\n6 chevrolet    k1500 taho…   5.3  2008     8 auto… 4        14    19 r     suv  \n```\n\n\n:::\n:::\n\n1. distinct will respect `group_by` and return distinct values for each group\n2. `keep_all` will keep the first row of values from all other columns\n\n\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}