---
title: "Tidyverse Essentials - `dplyr`"
subtitle: "The grammar of data wrangling"
author: "Matthew Scott"
date: "2024-07-24"
description: "Data wrangling: solve the most common data manipulation challenges"
categories: [tutorial, r, tidyverse, dplyr, tidyr]
image: "abstract-art.png"
image-alt: "An abstract sketch using broad brush strokes"
code-annotations: hover
draft: false
toc: true
---

![Abstract Canvas](abstract-art-wide.png){fig-alt="A picture I drew one time"}
```{r setup}
#| eval: true
#| echo: false

library(dplyr)
library(ggplot2)
```


## Introduction

Tidyverse is a collection of [R packages](https://www.tidyverse.org/packages/) designed for data science. All packages share an underlying design philosophy, grammar, and data structures.

**Installation** This can be done using `install.packages("tidyverse")`; `library(tidyverse)` to install and import all packages.

:::{.callout-tip appearance="simple" icon="true"}
## Tip 
Installing tidyverse will result in (usually) a lot of libraries your code isn't using being installed, which is not efficient. It is best practice (and helps your learning) to install packages individually. See below for popular tidyverse packages.
:::

### Popular Tidyverse packages

* [`dplyr`](https://dplyr.tidyverse.org/) - Solve the most common data manipulation challenges (**NB** `dbplyr` allows you to use remote database tables by converting dplyr code to SQL)
* [`readr`](https://readr.tidyverse.org/) - Read and write tabular data like csv and tsv formats. (NB there are options like `readxl`, `writexl` for working with excel files and `googlesheets4` for Google sheets)
* [`stringr`](https://stringr.tidyverse.org/) - Set of functions designed to make working with strings as easy as possible. It also incorporates Reg Ex patterns into its syntax. Many common data cleaning and preparation tasks involve string cleaning such as detecting matches, sub-setting strings, mutating strings, ordering, ...
* [`tidyr`](https://tidyr.tidyverse.org/) - A set of functions to help tidy data (each column is a row, each row an observation, and each cell a single value). `separate_wider_delim()`, `hoist()`, `pivot_longer()`, ...
* [`ggplot2`](https://ggplot2.tidyverse.org/) - A declarative package for making graphics. See also [R Graphics Cookbook](https://r-graphics.org/)
* [`purrr`](https://purrr.tidyverse.org/) - Provides a complete set of tools for working with functions and vectors. (The `map()` family can efficiently replace for loops). A good place to start learning is [here](https://r4ds.had.co.nz/iteration.html).

**Note** There are more packages than this including some helpful ones: `httr`, `lubridate`, `glue`, `modelr`, `forcats`.

## Installing & importing packages

```{r installing}
# installing
install.packages("tidyverse")
# or install specific packages
install.packages("dplyr")
install.packages("ggplot2")

# now import them into your session
library(tidyverse)
library(dplyr)
library(ggplot2)
```

## Inspecting a dataset

Some packages come with dataset you can work with, or you can inspect your own data

```{r inspecting}
# open ggplot2's data dictionary for this packages internal dataset
help("mpg")
# load the dataset into a variable
df <- mpg
# see information rich summary
glimpse(df)
# see top n rows
df %>% head(n=5) # <1>
```
1. You can also use `tail()` to see the bottom n rows

## `select()` & `rename()`

`select([df], helper_function([col_1], [col_2]))`

You can wrap the columns in helper functions:

* `contains(match, ignore.case = T)` - column name contains a certain string
* `starts_with(match, ignore.case = T)` - column names start with
* `ends_with(match, ignore.case = T)` - column names end with
* `matches(match, ignore.case = T)` - matches a regular expression
* `num_range(prefix, range, ...)` - names following the pattern e.g. `num_range("Wk", 1:3)`: "Wk1", "Wk2", "Wk3"
* `any_of()` - will select all columns available from a list
* `all_of()` - used for strict selection. Throws an error if one of the columns named in the list aren't present in the dataframe
* `matches()` - exactly matches a certain string
* `where(is.numeric())` - will select all numeric columns (int or dbl). Also `is.character`, `is.factor`, `is.integer`, `is.double`

`rename([new_name] = [old_name])`

```{r select-example}
# selecting column by index (position)

# select columns in position 1-3
select(df, 1:3)
# select columns in position 1-3
select(df, c(2, 5, 7))
# select from the second to last column to the last column
select(df, (ncol(df) -2) : ncol(df))

# selecting columns that contain 'l' (upper or lower case) 
# and renaming 'model' to 'type' etc.
df %>% 
  select(contains('l', ignore.case = T)) %>% 
  rename(type = model, cylinder = cyl)

# select and rename in one call
select(df, 
       mnfc = manufacturer, # <1>
       mod = model, # <1>
       everything()) # <2>

# select all numeric columns plus some extras
mpg %>%
  select(where(is.numeric), # <3>
         mnfc = manufacturer, # <4>
         mod = model) # <4>

# another approach: create a vector and use this with any_of()
numerical_cols <- c('displ', 'year', 'cyl', 'cty', 'hwy')
numerical_df <- df %>% 
  select(any_of(numerical_cols))

# negative selections
df %>% 
  select(-any_of(c(model, displ, cyl))) # <5>
```

1. select and rename in one call
2. select all remaining columns that haven't already been specified
3. this will select all column of data type int or dbl
4. add two additional non-numeric cols to your selection
5. remove any of these columns that appear in the dataframe

## `mutate()` & `transmute()`

`mutate([new_col] = [old_col(s) + logic])`

* creates a new column based on the logic provided
* you can create multiple columns at one time
* adds the new col to the df

`transmute([new_col] = [old_col(s) + logic])`

* creates a new column and drops other columns (this can be useful when do machine learning and you don't want the new columns interfering with the model)

Helpful functions for dealing with strings:

| Functions | 
|:------:|
| `as.character()` | 
| `as.date()` | 
| `as.integer()` | 

: {.striped .hover}

**Note** There is also `lubridate` and `hms` packages for working with dates and times that give a lot more flexibility. `stringr` is another useful package commonly used wiht mutate to extract parts of columns.

```{r}
#| eval: true
# create 'avg mpg' column and paste together two cols into 'car'
# this will return the full df plus these two new cols
mpg %>% 
    mutate(
         car = paste(manufacturer, model, sep = ' '),
        `avg mpg` = (( cty + hwy ) / 2 ),
         cty, # <1>
        .keep = "none") %>%  # <2>
    head(5)


```
1. We can specify the col name with no calc and it will get included
2. Acts like `transmute` to keep only created columns

Use `.by` to group our selection in a single expression. We return the max avg mpg for each model type:

```{r}
#| eval: true

mpg %>% 
    mutate(`avg mpg` = ((cty+hwy)/2),
           `max avg mpg` = max(`avg mpg`),
           .by = model,
           .keep = "used") # <1>
```
1. Now we keep only columns used in our mutate verb, including those used in the calculations.

### Common usage

Replace existing columns with mutated version of themselves, either by converting the data type or cleaning the column of NAs. Create new columns with mutate.

- `case_when()`
- `case_match()`
- `if_else()`
- `na_if()`

```{r}
# mutate with case_when
mpg %>% 
    mutate(
        "hwy_bins" = case_when(
            hwy < 20 ~ "low",
            between(hwy, 20, 30) ~ "medium",
            hwy > 30 ~ "high",
            TRUE ~ NA_character_
            ))

# mutate with if_else
mpg %>% 
    mutate(
        "is_offroad" = if_else(
            drv == "4", "Y", "N"
        ))

# mutate with na_if() to replace values with NA
mpg %>% 
    mutate(year = na_if(year, NaN)) # <1>


```
1. if NaN present, replace it with NA and this clean the column


### Other mutate verbs

* `mutate_all()` - affects every variable
* `mutate_if()` - affects variables selected with a predicate function
* `mutate_at()` - affects variables selected with a character variable or vars()

```{r}
# This code:
table_sep <- table %>%
  separate(col = date,
           into = c("year", "month", "dayofmonth"),
           sep = "-") %>%
  mutate(month = as.numeric(month), # <1>
         dayofmonth = as.numeric(dayofmonth)) %>% # <1>
  arrange(year, month, dayofmonth)

# is the same as this:
table_sep <- table %>%
  separate(col = date,
           into = c("year", "month", "dayofmonth"),
           sep = "-") %>%
  mutate_at(.vars = c("month", "dayofmonth"), # <2>
            .funs = as.numeric) # <2>
  arrange(year, month, dayofmonth)
```
1. Where we have to specify every column to change data type here...
2. ...we can supply the columns in a list and only have to specify the mutate function once

You can imagine if we had lots of columns to mutate, this would be much more succinct.

You can mutate any column that is.character/is.numier etc.:

```{r}
#| eval: true

mpg %>% 
    mutate_if(is.character, stringr::str_to_title) %>% # <1>
    select(is.character) %>% 
    head(4)
```
1. convert all character column to title case (upper case at start of each word)

